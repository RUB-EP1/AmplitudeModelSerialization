---
jupyter: julia-amplitude-serialization-1.10
---

# $\Lambda_b^0 \to p K^- \gamma$

This page demostrates deserialization and evaluation of an amplitude model for the decay $\Lambda_b^0 \to p K^- \gamma$. The resonant structure is studied using proton-proton collision data recorded at centre-of-mass energies of $7$, $8$, and $13$ TeV collected with the LHCb detector, [INSPIRE-HEP 2765817](https://inspirehep.net/literature/2765817).

```{julia}
#| code-fold: true
#| code-summary: Activate environment
#| output: false
import Pkg
Pkg.activate(@__DIR__)
Pkg.instantiate()

using ThreeBodyDecaysIO
using ThreeBodyDecaysIO.ThreeBodyDecays
using ThreeBodyDecaysIO.HadronicLineshapes
using ThreeBodyDecaysIO.Parameters
using ThreeBodyDecaysIO.DataFrames
using ThreeBodyDecaysIO.JSON
using Measurements
using Statistics
using QuadGK
using Plots

theme(:wong2, frame=:box, grid=false, minorticks=true,
    guidefontvalign=:top, guidefonthalign=:right,
    foreground_color_legend=nothing,
    xlim=(:auto, :auto), ylim=(:auto, :auto),
    lab="")
```

## Function definitions

Non-standard lineshapes are used to model resonances that do not conform to a simple `BreitWigner` distributions, or a `MultichannelBreitWigner` has to be defined explicitly.
The code below defines a new lineshape, and its deserialization method.

```{julia}
struct NonResonant <: HadronicLineshapes.AbstractFlexFunc
    m::Float64
end
function (BW::NonResonant)(Ïƒ)
    @unpack m = BW
    1.0
end
function ThreeBodyDecaysIO.dict2instance(::Type{NonResonant}, dict)
    @unpack mass = dict
    return NonResonant(mass)
end
```

## Deserialization of Objects to a Workspace

Model components are deserialized from a JSON file into computational objects within a workspace for further manipulation. First, functions representing lineshapes and formfactors are built. Following this, distributions are processed and added to the workspace.

```{julia}
input = open(joinpath(@__DIR__, "..", "..", "models", "Lb2pKg.json")) do io
    JSON.parse(io)
end

workspace = Dict{String,Any}()

@unpack functions = input
for fn in functions
    @unpack name, type = fn
    instance_type = eval(Symbol(type))
    workspace[name] = dict2instance(instance_type, fn)
end

@unpack distributions = input
for dist in distributions
    @unpack name, type = dist
    instance_type = eval(Symbol(type))
    workspace[name] = dict2instance(instance_type, distributions[1]; workspace)
end
```

## Validation

The integrity of the model is checked by validating the value of distributions at a few phase space points.
The table lists the validation checkes and their status ("ðŸŸ¢" or "ðŸ”´").

```{julia}
#| code-fold: true
#| code-summary: A loop over validation points
df = let
    @unpack misc, parameter_points = input
    @unpack amplitude_model_checksums = misc

    map(amplitude_model_checksums) do check_point_info
        @unpack name, value, distribution = check_point_info
        #
        # pull distribution
        dist = workspace[distribution]

        # pull correct parameter point
        parameter_points_dict = array2dict(parameter_points; key="name")
        # find the point in the list of points
        parameter_point = parameter_points_dict[name]
        # compute, compare
        _parameters = array2dict(parameter_point["parameters"];
            key="name", apply=v -> v["value"])
        #
        function label_diff(diff; levels=[1e-2, 1e-4])
            _diff = abs(diff)
            _diff < levels[2] && return 'ðŸŸ¢'
            _diff < levels[1] && return 'ðŸŸ¡'
            return 'ðŸ”´'
        end
        computed_value = dist(_parameters)
        status = label_diff(value - computed_value)
        (; Distribution=distribution, Reference=value, Computed_value=computed_value,
            Point=name, Status=status)
    end |> DataFrame
end
```

## Visualization

The model descibing the decay is fetched from the workspace

```{julia}
model_dist = [v for (k, v) in workspace if v isa HadronicUnpolarizedIntensity] |> first;
```

### Dalitz plot

The Dalitz plot shows the probability distribution across two dimensional phase space of the decay.

```{julia}
#| code-fold: true
#| code-summary: Dalitz plot plotting
let iÏƒx = 3, iÏƒy = 2
    xlab = ((i, j) = ij_from_k(iÏƒx);
    "mÂ²($i$j) [GeVÂ²]")
    ylab = ((i, j) = ij_from_k(iÏƒy);
    "mÂ²($i$j) [GeVÂ²]")
    model = model_dist.model

    plot(masses(model), Base.Fix1(unpolarized_intensity, model);
        iÏƒx, iÏƒy, xlab, ylab)
end
```

Test that the NonResonant part is implemented correctly.

```{julia}
let
    model = model_dist.model
    @assert model.chains[74].Xlineshape(3.5^2) == 1.0 "Not computed / normalized correctly"
end
```
